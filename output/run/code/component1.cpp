

/*
   Autogenerated BRAHMS process from SpineML description.
   Engine: XSLT
   Engine Author: Alex Cope 2012
   Node name: Neuron.xml
*/


#define COMPONENT_CLASS_STRING "dev/SpineML/temp/NB/Neuron"
#define COMPONENT_CLASS_CPP dev_spineml_nb_Neuron_0
#define COMPONENT_RELEASE 0
#define COMPONENT_REVISION 1
#define COMPONENT_ADDITIONAL "Author=SpineML_2_BRAHMS\n" "URL=Not supplied\n"
#define COMPONENT_FLAGS (F_NOT_RATE_CHANGER)

#define OVERLAY_QUICKSTART_PROCESS

//	include the component interface overlay (component bindings 1199)
#include "brahms-1199.h"

//	alias data and util namespaces to something briefer
namespace numeric = std_2009_data_numeric_0;
namespace spikes = std_2009_data_spikes_0;
namespace rng = std_2009_util_rng_0;

using namespace std;

#include "rng.h"
// Some very SpineML_2_BRAHMS specific defines, common to all components.
#define randomUniform     _randomUniform(&this->rngData_BRAHMS)
#define randomNormal      _randomNormal(&this->rngData_BRAHMS)
#define randomExponential _randomExponential(&this->rngData_BRAHMS)
#define randomPoisson     _randomPoisson(&this->rngData_BRAHMS)
#include "impulse.h"

/* helper function for doing the indexing... do we need this?
int getIndex(VDOUBLE position, VDOUBLE size) {

	int index = 0;
	int mult = 1;
	for (int i = 0; i < size.size(); ++i) {
		index = index + pos[i] * mult;
		mult = mult * size[i];
	}

}*/

// structure allowing weights to be sent with spikes
struct INT32SINGLE {
	INT32 i;
	SINGLE s;
};

float dt;

//float integrate(float, float);

// solver - could use better one!
/*float integrate(float x, float dx) {

	return x + dx*dt;

}*/

#define BRAHMS_STOP 0; brahms_stop = 1; 

class COMPONENT_CLASS_CPP;




////////////////	COMPONENT CLASS (DERIVES FROM Process)

class COMPONENT_CLASS_CPP : public Process
{

public:

	//	use ctor/dtor only if required
	COMPONENT_CLASS_CPP() {brahms_stop = 0;}
	~COMPONENT_CLASS_CPP() {bout << "FINISHED" << D_INFO;}

	//	the framework event function
	Symbol event(Event* event);

private:

// Some data for the random number generator.
RngData rngData_BRAHMS;

float t;

int brahms_stop;

// base name
string baseNameForLogs_BRAHMS;

// model directory string
string modelDirectory_BRAHMS;

// Determine if this weight update component has only FixedValue Parameters and
// FixedValue delays. Initialised to true; may be set false. If it remains true,
// then AllToAll connectivity may be optimised.
bool allParamsDelaysAreFixedValue;

// define regimes

#define NeuronX__XMain 1


// Global variables
vector < int > NeuronO__Oregime;
vector < int > NeuronO__OregimeNext;


VDOUBLE size_BRAHMS;
int numElements_BRAHMS;

// flag to see if we need to do model-wide things
bool is_first_pop_BRAHMS;
FILE * file_for_timestamp_BRAHMS;
string filepath_for_stop_BRAHMS;

// Analog Ports

numeric::Output PORTneuron_out;
//if using an alias then create the output variable

vector < double > neuron_outLOGVAR;
vector < int > neuron_outLOGMAP;
FILE * neuron_outLOGFILE;

numeric::Output PORTneuron_in_debug;
//if using an alias then create the output variable

vector < double > neuron_in_debug;

vector < double > neuron_in_debugLOGVAR;
vector < int > neuron_in_debugLOGMAP;
FILE * neuron_in_debugLOGFILE;

numeric::Input PORTneuron_in;
vector < double > neuron_in;


// Event Ports


// Impulse Ports


// State Variables

	vector <  double > neuron_out;
	string neuron_out_BINARY_FILE_NAME;
	string neuron_out_BINARY_FILE_NAME_OUT;

// Parameters


// Add aliases that are not inputs


// euler
float integrate(float x, float (COMPONENT_CLASS_CPP::*func)(float, int), int num) {

	return x + (*this.*func)(x,num)*dt;

}

// Runge Kutta 4th order
/*float integrate(float x, float (COMPONENT_CLASS_CPP::*func)(float, int), int num) {

	float k1 = dt*(*this.*func)(x,num);
	float k2 = dt*(*this.*func)(x+0.5*k1,num);
	float k3 = dt*(*this.*func)(x+0.5*k2,num);
	float k4 = dt*(*this.*func)(x+k3,num);
	return x + (1.0/6.0)*(k1 + 2.0*k2 + 2.0*k3 + k4);

}*/

float old_vals[3];

// Adams Bashforth 3rd order
/*float integrate(float x, float (COMPONENT_CLASS_CPP::*func)(float, int), int num) {

	for (int i = 0; i < 2; ++i)
		{old_vals[i] = old_vals[i+1];}
	old_vals[2] = (*this.*func)(x,num);
	return x + dt*((23.0/12.0)*old_vals[2] -(4.0/3.0)*old_vals[1] + (5.0/12.0)*old_vals[0]);;
}*/

};

////////////////	EVENT

Symbol COMPONENT_CLASS_CPP::event(Event* event)
{
	switch(event->type)
	{
		case EVENT_STATE_SET:
		{
			// Initialise allParamsDelaysAreFixedValue to false; no "allToAll" optimisation
			// for anything but weight update components
			this->allParamsDelaysAreFixedValue = false;

			//	extract DataML
			EventStateSet* data = (EventStateSet*) event->data;
			XMLNode xmlNode(data->state);
			DataMLNode nodeState(&xmlNode);

			rngDataInit(&this->rngData_BRAHMS);
			zigset(&this->rngData_BRAHMS, 11);

			// obtain the parameters
			size_BRAHMS = nodeState.getField("size").getArrayDOUBLE();
			numElements_BRAHMS = 1;
			for (int i_BRAHMS_LOOP = 0; i_BRAHMS_LOOP < size_BRAHMS.size(); ++i_BRAHMS_LOOP) {
				numElements_BRAHMS *= size_BRAHMS[i_BRAHMS_LOOP];
			}

			// Ensure field is present (trigger BRAHMS error if not)
			modelDirectory_BRAHMS = nodeState.getField("model_directory").getSTRING();

			// check if we need to do model-wide things
			is_first_pop_BRAHMS = false;
			file_for_timestamp_BRAHMS = NULL;
			if (nodeState.hasField("first_pop")) {
				is_first_pop_BRAHMS = true;
				string fileNameForTimestamp_BRAHMS = modelDirectory_BRAHMS;
				fileNameForTimestamp_BRAHMS.append("/time.txt");
				file_for_timestamp_BRAHMS = fopen(fileNameForTimestamp_BRAHMS.c_str(),"w");
				filepath_for_stop_BRAHMS = modelDirectory_BRAHMS;
				filepath_for_stop_BRAHMS.append("/stop.txt");
			}

			int numEl_BRAHMS = numElements_BRAHMS;

			// State Variables

			
			// Any state variable means that we can't optimise alltoall weight update components:
			this->allParamsDelaysAreFixedValue = false;
			{
			bool finishedThis = false;
			// see if not there at all (if so initialise to zero)
			if (!(nodeState.hasField("neuron_outRANDXOVER2") || \
				nodeState.hasField("neuron_outOVER2") || \
				nodeState.hasField("neuron_outRANDX") || \
				nodeState.hasField("neuron_out") || \
				nodeState.hasField("neuron_outOVER1") || \
				nodeState.hasField("neuron_outBIN_FILE_NAME"))) {
				neuron_out.resize(numEl_BRAHMS, 0);
			}

			if (nodeState.hasField("neuron_outRANDXOVER2")) {
				neuron_out = nodeState.getField("neuron_outRANDXOVER2").getArrayDOUBLE();
				float val1_BRAHMS = 0;
				float val2_BRAHMS = 1;
				// if normal distribution
				if (neuron_out[0] == 1) {
					val1_BRAHMS = neuron_out[1];
					val2_BRAHMS = neuron_out[2];
					this->rngData_BRAHMS.seed = neuron_out[3];
					if (this->rngData_BRAHMS.seed == 0)
						this->rngData_BRAHMS.seed = getTime();
					neuron_out.resize(numEl_BRAHMS, 0);
					for (UINT32 i_BRAHMS = 0; i_BRAHMS < numEl_BRAHMS; ++i_BRAHMS) {
						neuron_out[i_BRAHMS] = (RNOR(&this->rngData_BRAHMS) * val2_BRAHMS) + val1_BRAHMS;
					}
				}
				// if uniform distribution
				if (neuron_out[0] == 2) {
					val1_BRAHMS = neuron_out[1];
					val2_BRAHMS = neuron_out[2];
					this->rngData_BRAHMS.seed = neuron_out[3];
					if (this->rngData_BRAHMS.seed == 0)
						this->rngData_BRAHMS.seed = getTime();
					neuron_out.resize(numEl_BRAHMS, 0);
					for (UINT32 i_BRAHMS = 0; i_BRAHMS < numEl_BRAHMS; ++i_BRAHMS) {
						neuron_out[i_BRAHMS] = (UNI(&this->rngData_BRAHMS) * (val2_BRAHMS-val1_BRAHMS)) + val1_BRAHMS;
					}
				}
				finishedThis = true;
			}
			if (nodeState.hasField("neuron_outOVER2") && !finishedThis) {
				if (nodeState.getField("neuron_outOVER2").getDims()[0] == 1) {neuron_out = nodeState.getField("neuron_outOVER2").getArrayDOUBLE();
					if (neuron_out.size() == 1) {
						neuron_out.resize(numEl_BRAHMS, neuron_out[0]);
					} else if (neuron_out.size() != numEl_BRAHMS) {
						berr << "State Variable neuron_out has incorrect dimensions (Its size is " << neuron_out.size() << ", not " << numEl_BRAHMS << ")";
					}
					finishedThis = true;
				}
			}

			if (nodeState.hasField("neuron_outRANDX") && !finishedThis) {

				neuron_out = nodeState.getField("neuron_outRANDX").getArrayDOUBLE();
				float val1_BRAHMS = 0;
				float val2_BRAHMS = 1;
				// if normal distribution
				if (neuron_out[0] == 1) {
					val1_BRAHMS = neuron_out[1];
					val2_BRAHMS = neuron_out[2];
					this->rngData_BRAHMS.seed = neuron_out[3];
					if (this->rngData_BRAHMS.seed == 0)
						this->rngData_BRAHMS.seed = getTime();
					neuron_out.resize(numEl_BRAHMS, 0);
					for (UINT32 i_BRAHMS = 0; i_BRAHMS < numEl_BRAHMS; ++i_BRAHMS) {
						neuron_out[i_BRAHMS] = (RNOR(&this->rngData_BRAHMS) * val2_BRAHMS) + val1_BRAHMS;
					}
				}
				// if uniform distribution
				if (neuron_out[0] == 2) {
					val1_BRAHMS = neuron_out[1];
					val2_BRAHMS = neuron_out[2];
					this->rngData_BRAHMS.seed = neuron_out[3];
					if (this->rngData_BRAHMS.seed == 0)
						this->rngData_BRAHMS.seed = getTime();
					neuron_out.resize(numEl_BRAHMS, 0);
					for (UINT32 i_BRAHMS = 0; i_BRAHMS < numEl_BRAHMS; ++i_BRAHMS) {
						neuron_out[i_BRAHMS] = (UNI(&this->rngData_BRAHMS) * (val2_BRAHMS-val1_BRAHMS)) + val1_BRAHMS;
					}
				}
			}

			if (nodeState.hasField("neuron_out") && !finishedThis) {
			neuron_out = nodeState.getField("neuron_out").getArrayDOUBLE();
				if (neuron_out.size() == 1) {
					neuron_out.resize(numEl_BRAHMS, neuron_out[0]);
				} else if (neuron_out.size() != numEl_BRAHMS) {
					berr << "State Variable neuron_out has incorrect dimensions (Its size is " << neuron_out.size() << ", not " << numEl_BRAHMS << ")";
				}
			}

			if (nodeState.hasField("neuron_outBIN_FILE_NAME") && !finishedThis) {
			        if (!nodeState.hasField("neuron_outBIN_NUM_ELEMENTS")) {
				        berr << "Found a binary file name without corresponding binary number of elements.";
				}
				neuron_out_BINARY_FILE_NAME = nodeState.getField("neuron_outBIN_FILE_NAME").getSTRING();
				int __temp_num_property_elements = nodeState.getField("neuron_outBIN_NUM_ELEMENTS").getINT32();

				// open the file for reading
				FILE * binfile;

				string fileName = modelDirectory_BRAHMS + "/" + neuron_out_BINARY_FILE_NAME;
				binfile = fopen(fileName.c_str(),"rb");
				if (!binfile) {
					berr << "Could not open properties list file: " << fileName;
				}

				neuron_out.resize(__temp_num_property_elements);
				vector<INT32> __temp_property_list_indices (__temp_num_property_elements, 0);
				vector<DOUBLE> __temp_property_list_values (__temp_num_property_elements, 0);
				for (int i_BRAHMS = 0; i_BRAHMS < __temp_num_property_elements; ++i_BRAHMS) {

					size_t ret_FOR_BRAHMS = fread(&__temp_property_list_indices[i_BRAHMS], sizeof(INT32), 1, binfile);
					if (ret_FOR_BRAHMS == -1) {berr << "Error loading binary properties: Failed to read an index";}
					ret_FOR_BRAHMS = fread(&__temp_property_list_values[i_BRAHMS], sizeof(DOUBLE), 1, binfile);
					if (ret_FOR_BRAHMS == -1) {berr << "Error loading binary properties: Failed to read a value";}
				}
				for (int i_BRAHMS = 0; i_BRAHMS < __temp_num_property_elements; ++i_BRAHMS) {
				        if ( __temp_property_list_indices[i_BRAHMS] > __temp_num_property_elements
					    || __temp_property_list_indices[i_BRAHMS] < 0) {
					    berr << "Error loading binary state variable property neuron_out: index "
						 << __temp_property_list_indices[i_BRAHMS] << " out of range";
					}
					neuron_out[__temp_property_list_indices[i_BRAHMS]] = __temp_property_list_values[i_BRAHMS];
				}
			}

			
			if (nodeState.hasField("neuron_outOVER1") && !finishedThis)
			{
				vector < double > __tempInputValues__;
				__tempInputValues__ = nodeState.getField("neuron_outOVER1").getArrayDOUBLE();
				// since OVER1 always means sparse Values
				if (neuron_out.size() == 1) {neuron_out.resize(numEl_BRAHMS, neuron_out[0]);
				}
				if (neuron_out.size() != numEl_BRAHMS) {berr << "State Variable neuron_out has a ValueList override but no base Values";}
				for (UINT32 i_BRAHMS = 0; i_BRAHMS < __tempInputValues__.size(); i_BRAHMS += 2) {
					if (__tempInputValues__[i_BRAHMS] > numEl_BRAHMS-1) {berr << "State Variable neuron_out has ValueList index " << float(i_BRAHMS)<< " (value of " << float(__tempInputValues__[i_BRAHMS]) << ") out of range";}
					neuron_out[__tempInputValues__[i_BRAHMS]] = __tempInputValues__[i_BRAHMS+1];
				}

			}

			if (nodeState.hasField("neuron_outOVER2") && !finishedThis)
			{
				vector < double > __tempInputValues__;
				__tempInputValues__ = nodeState.getField("neuron_outOVER2").getArrayDOUBLE();
				// OVER2 here means sparse Values
				if (neuron_out.size() != numEl_BRAHMS) {berr << "Experiment State Variable neuron_out has a ValueList override but no base Values";}
				for (UINT32 i_BRAHMS = 0; i_BRAHMS < __tempInputValues__.size(); i_BRAHMS += 2) {
					if (__tempInputValues__[i_BRAHMS] > numEl_BRAHMS-1) {berr << "Experiment State Variable neuron_out has ValueList index " << float(i_BRAHMS)<< " (value of " << float(__tempInputValues__[i_BRAHMS]) << ") out of range";}
					neuron_out[__tempInputValues__[i_BRAHMS]] = __tempInputValues__[i_BRAHMS+1];
				}

			}

			// output the values:
			/*bout << "neuron_out" << D_WARN;
			for (UINT32 i_BRAHMS = 0; i_BRAHMS < neuron_out.size(); ++i_BRAHMS) {
				bout << float(neuron_out[i_BRAHMS]) << D_WARN;
			}*/
			}


			// Parameters


			// Alias resize
neuron_in_debug.resize(numEl_BRAHMS, 0);
			
			baseNameForLogs_BRAHMS = "../log/" + nodeState.getField("logfileNameForComponent").getSTRING();
			neuron_out_BINARY_FILE_NAME_OUT = "../model/" + nodeState.getField("neuron_outBIN_FILE_NAME").getSTRING();
			

			// Logs

			// check for existence of log stateNode
			if (nodeState.hasField("neuron_outLOG")) {
				// we have a log! Read the data in:
				// check we got some data first
				VDOUBLE tempLogData_BRAHMS = nodeState.getField("neuron_outLOG").getArrayDOUBLE();
				if (tempLogData_BRAHMS.size() == 0) berr << "ERROR: log with no indices";
				// if we are logging 'all'
				if (tempLogData_BRAHMS[0] < -0.1) {
					neuron_outLOGMAP.push_back(-2);
				} else {
				// otherwise
					// resize the logvar:
					neuron_outLOGVAR.resize(tempLogData_BRAHMS.size(),0);
					// resize the logmap:
					neuron_outLOGMAP.resize(numEl_BRAHMS,-1);
					// set the logmap values - checking for out of range values
					for (unsigned int i_BRAHMS = 0; i_BRAHMS < tempLogData_BRAHMS.size(); ++i_BRAHMS) {
						if (tempLogData_BRAHMS[i_BRAHMS]+0.5 > numEl_BRAHMS) {
							bout << "Attempting to log an index out of range" << D_WARN;
						} else {
							// set in mapping that the i_BRAHMSth log value relates to the tempLogData_BRAHMS[i_BRAHMS]th neuron
							neuron_outLOGMAP[(int) tempLogData_BRAHMS[i_BRAHMS]] = i_BRAHMS;
						}
					}
				}
				// open the logfile for writing
				string logFileName_BRAHMS = baseNameForLogs_BRAHMS;
				logFileName_BRAHMS.append("_neuron_out_log.bin");
				neuron_outLOGFILE = fopen(logFileName_BRAHMS.c_str(),"wb");
			}

			// check for existence of log stateNode
			if (nodeState.hasField("neuron_in_debugLOG")) {
				// we have a log! Read the data in:
				// check we got some data first
				VDOUBLE tempLogData_BRAHMS = nodeState.getField("neuron_in_debugLOG").getArrayDOUBLE();
				if (tempLogData_BRAHMS.size() == 0) berr << "ERROR: log with no indices";
				// if we are logging 'all'
				if (tempLogData_BRAHMS[0] < -0.1) {
					neuron_in_debugLOGMAP.push_back(-2);
				} else {
				// otherwise
					// resize the logvar:
					neuron_in_debugLOGVAR.resize(tempLogData_BRAHMS.size(),0);
					// resize the logmap:
					neuron_in_debugLOGMAP.resize(numEl_BRAHMS,-1);
					// set the logmap values - checking for out of range values
					for (unsigned int i_BRAHMS = 0; i_BRAHMS < tempLogData_BRAHMS.size(); ++i_BRAHMS) {
						if (tempLogData_BRAHMS[i_BRAHMS]+0.5 > numEl_BRAHMS) {
							bout << "Attempting to log an index out of range" << D_WARN;
						} else {
							// set in mapping that the i_BRAHMSth log value relates to the tempLogData_BRAHMS[i_BRAHMS]th neuron
							neuron_in_debugLOGMAP[(int) tempLogData_BRAHMS[i_BRAHMS]] = i_BRAHMS;
						}
					}
				}
				// open the logfile for writing
				string logFileName_BRAHMS = baseNameForLogs_BRAHMS;
				logFileName_BRAHMS.append("_neuron_in_debug_log.bin");
				neuron_in_debugLOGFILE = fopen(logFileName_BRAHMS.c_str(),"wb");
			}

			NeuronO__Oregime.resize(numEl_BRAHMS,1);
			NeuronO__OregimeNext.resize(numEl_BRAHMS,0);

			for (int i_BRAHMS = 0; i_BRAHMS < 3; ++i_BRAHMS) old_vals[i_BRAHMS] = 0;
			dt = 1000.0f * time->sampleRate.den / time->sampleRate.num; // time step in ms



		}

		// CREATE THE PORTS
		case EVENT_INIT_CONNECT:
		{
			Dims sizeDims_BRAHMS;
			for (int i_BRAHMS = 0; i_BRAHMS < size_BRAHMS.size(); ++i_BRAHMS) {
				sizeDims_BRAHMS.push_back(size_BRAHMS[i_BRAHMS]);
			}
			//	on first call
			if (event->flags & F_FIRST_CALL)
			{


				PORTneuron_out.setName("neuron_out");
				PORTneuron_out.create(hComponent);
				PORTneuron_out.setStructure(TYPE_REAL | TYPE_DOUBLE, Dims(numElements_BRAHMS).cdims());
      
				PORTneuron_in_debug.setName("neuron_in_debug");
				PORTneuron_in_debug.create(hComponent);
				PORTneuron_in_debug.setStructure(TYPE_REAL | TYPE_DOUBLE, Dims(numElements_BRAHMS).cdims());
      

			}

			//	on last call
			if (event->flags & F_LAST_CALL)
			{

				int numInputs_BRAHMS;
				Symbol set_BRAHMS;

				// create input ports

				PORTneuron_in.attach(hComponent, "neuron_in");
				PORTneuron_in.validateStructure(TYPE_REAL | TYPE_DOUBLE, Dims(numElements_BRAHMS).cdims());



			}

			// re-seed
			this->rngData_BRAHMS.seed = getTime();

			//	ok
			return C_OK;
		}

		case EVENT_RUN_SERVICE:
		{

			t = float(time->now)*dt;

			// do model wide things if we are the first pop
			if (is_first_pop_BRAHMS) {
				if (file_for_timestamp_BRAHMS) {
					// rewind the file and print the time
					fseek(file_for_timestamp_BRAHMS,0,SEEK_SET);
					fprintf(file_for_timestamp_BRAHMS, "%f", t);
				}
				// see if we need to stop
				FILE * do_we_stop = fopen(filepath_for_stop_BRAHMS.c_str(),"r");
				// if we can open the file, then it exists and we should terminate
				if (do_we_stop) {
					return C_STOP_CONDITION;
				}
			}

			int num_BRAHMS;
			int numEl_BRAHMS = numElements_BRAHMS;

			


			// service inputs
			neuron_in.resize(numElements_BRAHMS);
			memcpy(&neuron_in[0], PORTneuron_in.getContent(), numElements_BRAHMS*sizeof(DOUBLE));

			// template match="SMLCL:Dynamics" mode="doEventInputs"
			
			// template match="SMLCL:Dynamics" mode="doImpulseInputs"
			
			// template match="SMLCL:Dynamics" mode="doIter"
			
			// Dynamics time derivatives
			for (num_BRAHMS = 0; num_BRAHMS < numEl_BRAHMS; ++num_BRAHMS) {

				// switch on regime:
				switch (NeuronO__Oregime[num_BRAHMS]) {
	
					//Regime
					case NeuronX__XMain:
					{
	
					}
					break;

				}
			}
			
			// template match="SMLCL:Dynamics" mode="doTrans
			
			// Dynamics transitions
			for (num_BRAHMS = 0; num_BRAHMS < numEl_BRAHMS; ++num_BRAHMS) {


				// switch on regime:
				switch (NeuronO__Oregime[num_BRAHMS]) {
	
					//Regime
					case NeuronX__XMain:
					{
	
					bool transidm7 = false;
					if (1==1) {
						transidm7 = true;
					}

					//OnCondition
					if (transidm7) {
					//transition = true;
						//StateAssignment
					neuron_out[num_BRAHMS] = neuron_in[num_BRAHMS]+neuron_out[num_BRAHMS]; NeuronO__OregimeNext[num_BRAHMS]=NeuronX__XMain;
					}

					}
					break;

				}
			}
			
			for (num_BRAHMS = 0; num_BRAHMS < numEl_BRAHMS; ++num_BRAHMS) {

					//Alias assignment for ports
					neuron_in_debug[num_BRAHMS]=neuron_in[num_BRAHMS];
					
			}
			

			// Apply regime changes and update logs
			for (int i_BRAHMS = 0; i_BRAHMS < NeuronO__Oregime.size(); ++i_BRAHMS) {
			

           		// updating logs: "AnalogSendPort" mode="makeSendPortLogs"
           		
				if (neuron_outLOGMAP.size() > 0) {
					if (neuron_outLOGMAP[0] > -1.1) {
						if (neuron_outLOGMAP[i_BRAHMS]+1)
							neuron_outLOGVAR[neuron_outLOGMAP[i_BRAHMS]] = neuron_out[i_BRAHMS];
					}
				}

				if (neuron_in_debugLOGMAP.size() > 0) {
					if (neuron_in_debugLOGMAP[0] > -1.1) {
						if (neuron_in_debugLOGMAP[i_BRAHMS]+1)
							neuron_in_debugLOGVAR[neuron_in_debugLOGMAP[i_BRAHMS]] = neuron_in_debug[i_BRAHMS];
					}
				}


			}

			// updating logs... "EventSendPort" mode="makeSendPortLogs"
			

			// updating logs... "ImpulseSendPort" mode="makeSendPortLogs"
			

			// writing logs... "AnalogSendPort" mode="saveSendPortLogs"
			
				if (neuron_outLOGMAP.size() > 0) {
					if (neuron_outLOGMAP[0] < -1.1) {
						// write data
						size_t written_BRAHMS = fwrite(&neuron_out[0],sizeof(double),neuron_out.size(),neuron_outLOGFILE);
						if (written_BRAHMS != neuron_out.size()) berr << "Error writing logfile for " << baseNameForLogs_BRAHMS << "_neuron_out";
					} else {
						// write data
						size_t written_BRAHMS = fwrite(&neuron_outLOGVAR[0],sizeof(double),neuron_outLOGVAR.size(),neuron_outLOGFILE);
						if (written_BRAHMS != neuron_outLOGVAR.size()) berr << "Error writing logfile for " << baseNameForLogs_BRAHMS << "_neuron_out";
					}
				}

				if (neuron_in_debugLOGMAP.size() > 0) {
					if (neuron_in_debugLOGMAP[0] < -1.1) {
						// write data
						size_t written_BRAHMS = fwrite(&neuron_in_debug[0],sizeof(double),neuron_in_debug.size(),neuron_in_debugLOGFILE);
						if (written_BRAHMS != neuron_in_debug.size()) berr << "Error writing logfile for " << baseNameForLogs_BRAHMS << "_neuron_in_debug";
					} else {
						// write data
						size_t written_BRAHMS = fwrite(&neuron_in_debugLOGVAR[0],sizeof(double),neuron_in_debugLOGVAR.size(),neuron_in_debugLOGFILE);
						if (written_BRAHMS != neuron_in_debugLOGVAR.size()) berr << "Error writing logfile for " << baseNameForLogs_BRAHMS << "_neuron_in_debug";
					}
				}

			PORTneuron_out.setContent(&neuron_out[0]);

			PORTneuron_in_debug.setContent(&neuron_in_debug[0]);



			//	ok
			if (brahms_stop == 0) {
				return C_OK;
			} else {
			  return C_STOP_CONDITION;
			}
		}

		case EVENT_RUN_STOP:
		{
			int numEl_BRAHMS = numElements_BRAHMS;
			t = float(time->now)*dt;
			
			if (neuron_outLOGMAP.size() > 0) {
				
				FILE * neuron_outLOGREPORT;
				string logFileName_BRAHMS = baseNameForLogs_BRAHMS;
				logFileName_BRAHMS.append("_neuron_out_logrep.xml");
				neuron_outLOGREPORT = fopen(logFileName_BRAHMS.c_str(),"w");
				logFileName_BRAHMS = baseNameForLogs_BRAHMS;
				logFileName_BRAHMS.append("_neuron_out_log.bin");
				unsigned found = logFileName_BRAHMS.find_last_of("/\\");
				logFileName_BRAHMS = logFileName_BRAHMS.substr(found+1);
				fprintf(neuron_outLOGREPORT, "<LogReport>\n");
				fprintf(neuron_outLOGREPORT, "	<AnalogLog>\n");
				fprintf(neuron_outLOGREPORT, "		<LogFile>%s</LogFile>\n",logFileName_BRAHMS.c_str());
				fprintf(neuron_outLOGREPORT, "		<LogFileType>binary</LogFileType>\n");
				fprintf(neuron_outLOGREPORT, "		<LogEndTime>%f</LogEndTime>\n",t);
				if (neuron_outLOGMAP[0] > -1.1) {
					for (unsigned int i = 0; i < neuron_outLOGMAP.size(); ++i) {
						if (neuron_outLOGMAP[i] > -0.1) {
							fprintf(neuron_outLOGREPORT, "		<LogCol index=\"%d\" heading=\"neuron_out\" dims=\"\" type=\"double\"/>\n",i);
						}
					}
				} else {
					fprintf(neuron_outLOGREPORT, "		<LogAll size=\"%d\" headings=\"neuron_out\" type=\"double\" dims=\"\"/>\n",numEl_BRAHMS);
				}
				fprintf(neuron_outLOGREPORT,"		<TimeStep dt=\"%f\"/>\n", dt);
				fprintf(neuron_outLOGREPORT, "	</AnalogLog>\n");
				fprintf(neuron_outLOGREPORT, "</LogReport>\n");

				fclose(neuron_outLOGREPORT);
				fclose(neuron_outLOGFILE);
			}

			if (neuron_in_debugLOGMAP.size() > 0) {
				
				FILE * neuron_in_debugLOGREPORT;
				string logFileName_BRAHMS = baseNameForLogs_BRAHMS;
				logFileName_BRAHMS.append("_neuron_in_debug_logrep.xml");
				neuron_in_debugLOGREPORT = fopen(logFileName_BRAHMS.c_str(),"w");
				logFileName_BRAHMS = baseNameForLogs_BRAHMS;
				logFileName_BRAHMS.append("_neuron_in_debug_log.bin");
				unsigned found = logFileName_BRAHMS.find_last_of("/\\");
				logFileName_BRAHMS = logFileName_BRAHMS.substr(found+1);
				fprintf(neuron_in_debugLOGREPORT, "<LogReport>\n");
				fprintf(neuron_in_debugLOGREPORT, "	<AnalogLog>\n");
				fprintf(neuron_in_debugLOGREPORT, "		<LogFile>%s</LogFile>\n",logFileName_BRAHMS.c_str());
				fprintf(neuron_in_debugLOGREPORT, "		<LogFileType>binary</LogFileType>\n");
				fprintf(neuron_in_debugLOGREPORT, "		<LogEndTime>%f</LogEndTime>\n",t);
				if (neuron_in_debugLOGMAP[0] > -1.1) {
					for (unsigned int i = 0; i < neuron_in_debugLOGMAP.size(); ++i) {
						if (neuron_in_debugLOGMAP[i] > -0.1) {
							fprintf(neuron_in_debugLOGREPORT, "		<LogCol index=\"%d\" heading=\"neuron_in_debug\" dims=\"\" type=\"double\"/>\n",i);
						}
					}
				} else {
					fprintf(neuron_in_debugLOGREPORT, "		<LogAll size=\"%d\" headings=\"neuron_in_debug\" type=\"double\" dims=\"\"/>\n",numEl_BRAHMS);
				}
				fprintf(neuron_in_debugLOGREPORT,"		<TimeStep dt=\"%f\"/>\n", dt);
				fprintf(neuron_in_debugLOGREPORT, "	</AnalogLog>\n");
				fprintf(neuron_in_debugLOGREPORT, "</LogReport>\n");

				fclose(neuron_in_debugLOGREPORT);
				fclose(neuron_in_debugLOGFILE);
			}

			// Write variable name: neuron_out into a file.
			{
				unsigned char copy_buffer_BRAHMS[1024] = "";
				FILE* neuron_out_svfile;
				string neuron_out_fileName = neuron_out_BINARY_FILE_NAME_OUT;
#ifdef MAKE_BACKUP_OF_ORIGINAL_STATE
				neuron_out_svfile = fopen (neuron_out_fileName.c_str(), "rb");
				if (neuron_out_svfile) {
					
					string neuron_out_fileName_backup = neuron_out_fileName + ".bu";
					FILE* neuron_out_svfile_backup;
					neuron_out_svfile_backup = fopen (neuron_out_fileName_backup.c_str(), "wb");
					if (!neuron_out_svfile) {
						berr << "Could not open state variable backup file: " << neuron_out_fileName_backup;
					}
					
					size_t bytes_copied_BRAHMS = 0;
					size_t bytes_really_copied = 0;
					while ((bytes_copied_BRAHMS = fread (copy_buffer_BRAHMS, 1, 1024, neuron_out_svfile)) > 0) {
						bytes_really_copied = fwrite (copy_buffer_BRAHMS, 1, bytes_copied_BRAHMS, neuron_out_svfile_backup);
						if (bytes_really_copied != bytes_copied_BRAHMS) {
							berr << "Error making state variable backup file: " << neuron_out_fileName_backup;
						}
					}
					fclose (neuron_out_svfile_backup);
					fclose (neuron_out_svfile);
				}
#endif
				neuron_out_svfile = fopen (neuron_out_fileName.c_str(), "wb");
				if (!neuron_out_svfile) {
					berr << "Could not open state variable file: " << neuron_out_fileName;
				}
				
				int writertn_BRAHMS = 0, writeiter_BRAHMS = 0;
				while (writeiter_BRAHMS < this->neuron_out.size()) {
					writertn_BRAHMS = fwrite (reinterpret_cast<const char*>(&writeiter_BRAHMS), sizeof(int), 1, neuron_out_svfile);
					if (writertn_BRAHMS != 1) {
						berr << "Failed to write index into " << neuron_out_fileName << ". Wrote " << writertn_BRAHMS << " ints, rather than 1";
					}
					writertn_BRAHMS = fwrite (reinterpret_cast<const char*>(&this->neuron_out[writeiter_BRAHMS]), sizeof(double), 1, neuron_out_svfile);
					if (writertn_BRAHMS != 1) {
						berr << "Failed to write data into " << neuron_out_fileName << ". Wrote " << writertn_BRAHMS << " doubles, rather than 1";
					}
					++writeiter_BRAHMS;
				}
				
				fclose (neuron_out_svfile);
			}


			return C_OK;
		}
	}

	//	if we service the event, we return C_OK
	//	if we don't, we should return S_NULL to indicate that we didn't
	return S_NULL;
}







//	include the second part of the overlay (it knows you've included it once already)
#include "brahms-1199.h"


